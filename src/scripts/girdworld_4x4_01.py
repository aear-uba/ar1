# -*- coding: utf-8 -*-
"""girdworld_4x4_01.ipynb

Automatically generated by Colab.


"""

# =====================================================================
# Algoritmo de Evaluación de Política
#
# =====================================================================
# _Aprendizaje por Refuerzo I
# _Maestria en Inteligencia Artificial
# _UBA
# _2025
# =====================================================================

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

'''

GridWorld de 4x4 (pseudocodigo)
 _______
|_|_|_|_|
|_|_|_|_|
|_|_|_|_|
|_|_|_|_|

=====================================================================
Entrada: π (la política a ser evaluada)
Inicializar un umbral θ > 0 (determina la precisión de la estimación)
Inicializar V(s) ← 0 para todo estado s

θ = 0.001
V(s') ← 0
Repetir:
    Δ ← 0
    Para cada estado s en S:
        v ← V(s')
        V(s) ← Σ π(a | s) Σ p(s', r | s, a) [r + γ V(s')]
        Δ ← max(Δ, |v - V(s)|)
hasta que Δ < θ
=====================================================================

'''

# Dimensiones del Gridworld
GRID_SIZE = 4

# Estado Destino (Recompensa Alta)
DESTINO_X, DESTINO_Y = 3, 3

# Factor de Descuento
gamma = 0.9

# Acciones posibles (arriba, abajo, izquierda, derecha)
ACCIONES = [(0, -1), (0, 1), (-1, 0), (1, 0)]

# Función para verificar si una celda es válida
def es_valido(x, y):
    return 0 <= x < GRID_SIZE and 0 <= y < GRID_SIZE

# Función para calcular la recompensa
def calcular_recompensa(x, y):
    if x == DESTINO_X and y == DESTINO_Y:
        return 10  # Recompensa alta en el destino
    else:
        return -0.1 # Penalización por paso

# Inicialización de los valores de los estados (todos 0 al principio)
valores_estados = np.zeros((GRID_SIZE, GRID_SIZE))

# Inicialización del historial de valores
historial = [valores_estados.copy()] # Guarda la primera iteración (inicializada con 0)


threshold = 0.0001
delta = float('inf')

while delta > threshold:
    delta = 0
    nuevos_valores = np.zeros((GRID_SIZE, GRID_SIZE)) # Valores para la iteración actual

    for x in range(GRID_SIZE):
        for y in range(GRID_SIZE):
            mejor_valor = float('-inf')
            for dx, dy in ACCIONES:
                nuevo_x, nuevo_y = x + dx, y + dy
                if es_valido(nuevo_x, nuevo_y):
                    recompensa = calcular_recompensa(x, y)
                    valor = recompensa + gamma * valores_estados[nuevo_x, nuevo_y]
                    mejor_valor = max(mejor_valor, valor)

            nuevos_valores[x, y] = mejor_valor if mejor_valor != float('-inf') else calcular_recompensa(x,y) # Manejo de estados sin acciones válidas
            delta = max(delta, abs(nuevos_valores[x, y] - valores_estados[x, y]))

    valores_estados = nuevos_valores
    historial.append(valores_estados.copy())

# Visualización con Matplotlib

# Selección de iteraciones a mostrar
num_iteraciones_a_mostrar = min(5, len(historial))  # Mostrar hasta 5 iteraciones si hay menos
iteraciones_a_mostrar = list(range(num_iteraciones_a_mostrar))
iteraciones_a_mostrar.append(len(historial) - 1) # Agrega la ultima iteracion
titulos = [f"Iteración {i}" for i in range(num_iteraciones_a_mostrar)] # Titulos de las primeras iteraciones
titulos.append(f"Iteración Final ({len(historial) - 1})") # Titulo de la ultima iteracion


fig, axs = plt.subplots(1, len(iteraciones_a_mostrar), figsize=(15, 5))

for i, iteracion in enumerate(iteraciones_a_mostrar):
    ax = axs[i]
    im = ax.imshow(historial[iteracion], cmap="viridis")
    ax.set_title(titulos[i])

    # Anotaciones para cada celda
    for x in range(GRID_SIZE):
        for y in range(GRID_SIZE):
            text = ax.text(y, x, f"{historial[iteracion][x, y]:.2f}",
                           ha="center", va="center", color="w") # 2 decimales

    ax.set_xticks(np.arange(GRID_SIZE))
    ax.set_yticks(np.arange(GRID_SIZE))
    ax.set_xticklabels([])  # Oculta etiquetas de los ejes
    ax.set_yticklabels([])

fig.colorbar(im, ax=axs.ravel().tolist(), shrink=0.8)  # Barra de color

plt.tight_layout()
plt.show()