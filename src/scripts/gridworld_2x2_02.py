# -*- coding: utf-8 -*-
"""gridworld_2x2_02.ipynb

Automatically generated by Colab.


"""

# =====================================================================
# Algoritmo de Evaluación de Política
#
# =====================================================================
# _Aprendizaje por Refuerzo I
# _Maestria en Inteligencia Artificial
# _UBA
# _2025
# =====================================================================

import numpy as np
from numpy.linalg import inv

'''
=======================================================================
GridWorld de 2x2 - Resolución de Evaluación de Política por Algebra Lineal
(Método de Inversión de Matrices)
=======================================================================

 ___ ___
|   |   |
| A | B |
|___|___|
|   |   |
| C | D |
|___|___|

Dado un sistema de ecuaciones lineales que puede expresarse en forma matricial
como Ax = b, donde:

    A es la matriz de coeficientes.
    x es el vector de incógnitas (los valores de los estados).
    b es el vector de términos independientes (las recompensas).

A⁻¹ * Ax = A⁻¹ * b
Ix = A⁻¹ * b
x = A⁻¹ * b

Donde I es la matriz identidad.

La solución para x se encuentra multiplicando ambos lados de la ecuación por la
inversa de A (denotada como A⁻¹):

las ecuaciones de Belman a programar son

    V(A) = 1/4 (5 + γ V(B)) + 1/4 (0 + γ V(C)) + 1/2 (0 + γ V(A))

    V(B) = 1/4 (0 + γ V(A)) + 1/4 (0 + γ V(D)) + 1/2 (5 + γ V(B))

    V(C) = 1/4 (0 + γ V(A)) + 1/4 (0 + γ V(D)) + 1/2 (0 + γ V(C))

    V(D) = 1/4 (5 + γ V(B)) + 1/4 (0 + γ V(C)) + 1/2 (0 + γ V(D))

modelando esto en álgebra lineal:

V(A) = (5/4) + (0.7/4)V(B) + (0.7/4)V(C) + (0.7/2)V(A)
V(B) = (5/2) + (0.7/4)V(A) + (0.7/4)V(D) + (0.7/2)V(B)
V(C) = (0.7/4)V(A) + (0.7/4)V(D) + (0.7/2)V(C)
V(D) = (5/4) + (0.7/4)V(B) + (0.7/4)V(C) + (0.7/2)V(D)

los valores se pasan para el otro lado quedando:

V(A) - (0.7/2)V(A) - (0.7/4)V(B) - (0.7/4)V(C) = 5/4
V(B) - (0.7/2)V(B) - (0.7/4)V(A) - (0.7/4)V(D) = 5/2
V(C) - (0.7/2)V(C) - (0.7/4)V(A) - (0.7/4)V(D) = 0
V(D) - (0.7/2)V(D) - (0.7/4)V(B) - (0.7/4)V(C) = 5/4

operando los coeficientes de las variables:

(0.7/2)=0.35
(1-0.35)=0.65
(0.7/4)=0.175

la matriz entonces seria:

(0.65)A +(-0.175)B +(-0.175)C= 5/4
(-0.175)A + (0.65)B +(-0)C +(-0.175)D = 5/2
(-0.175)A +(0)B +(0.65)C+(-0.175)D=0
(0)A +(-0.175)B +(-0.175)C+(0.65)D = 5/4

por lo tanto la matriz de coeficientes es:

[0.65, -0.175, -0.175, 0] para v(A)
[-0.175, 0.65, 0, -0.175] para v(B)
[-0.175, 0, 0.65, -0.175] para v(C)
[0, -0.175, -0.175, 0.65] para v(D)

[5/4] para v(A)
[5/2] para v(B)
[0] para v(C)
[5/4] para v(D)

'''

# Definición de estados
estados = ["A", "B", "C", "D"]

# Factor de Descuento
gamma = 0.7

# Definición de las ecuaciones en forma matricial
# Ax = b, donde x = [V(A), V(B), V(C), V(D)]

# Matriz A: Coeficientes de las variables V(A), V(B), V(C), V(D)
A = np.array([
    [0.65, -0.175, -0.175, 0],  # Ecuación para V(A)
    [-0.175, 0.65, 0, -0.175],  # Ecuación para V(B)
    [-0.175, 0, 0.65, -0.175],  # Ecuación para V(C)
    [0, -0.175, -0.175, 0.65]   # Ecuación para V(D)
])

# Vector b: Términos independientes
b = np.array([
    [5/4],  # Recompensa en el estado A
    [5/2],  # Recompensa en el estado B
    [0],    # Recompensa en el estado C
    [5/4]   # Recompensa en el estado D
])

# Resolver el sistema de ecuaciones Ax = b
x = inv(A).dot(b)

# Imprimir la solución
print("Valores de los estados:")
for i, estado in enumerate(estados):
    print(f"{estado}: {x[i, 0]:.4f}")