# -*- coding: utf-8 -*-
"""gridworld_2x2_01.ipynb

Automatically generated by Colab.



# =====================================================================
# Algoritmo de Evaluación de Política
#
# =====================================================================
# _Aprendizaje por Refuerzo I
# _Maestria en Inteligencia Artificial
# _UBA
# _2025
# =====================================================================

import numpy as np

'''

GridWorld de 2x2 (pseudocodigo)
 ___ ___
|   |   |
| A | B |
|___|___|
|   |   |
| C | D |
|___|___|

=====================================================================
Entrada: π (la política a ser evaluada)
Inicializar un umbral θ > 0 (determina la precisión de la estimación)
Inicializar V(s) ← 0 para todo estado s

Repetir:
    Δ ← 0
    Para cada estado s en S:
        v ← V(s)
        V(s) ← Σ π(a | s) Σ p(s', r | s, a) [r + γ V(s')]
        Δ ← max(Δ, |v - V(s)|)
hasta que Δ < θ
=====================================================================

'''

# Estados
estados = ["A", "B", "C", "D"]

# Factor de Descuento
gamma = 0.7

# Inicialización de Valores de los Estados
valores_estados = {}
for estado in estados:
    valores_estados[estado] = 0

# Umbral de Convergencia
threshold = 0.00001

# Dinamica del Entorno y Politica (Implicita)
def calcular_valor_estado(estado, valores):
    if estado == "A":
        return 1/4 * (5 + gamma * valores["B"]) + 1/4 * (0 + gamma * valores["C"]) + 1/2 * (0 + gamma * valores["A"])
    elif estado == "B":
        return 1/4 * (0 + gamma * valores["A"]) + 1/4 * (0 + gamma * valores["D"]) + 1/2 * (5 + gamma * valores["B"])
    elif estado == "C":
        return 1/4 * (0 + gamma * valores["A"]) + 1/4 * (0 + gamma * valores["D"]) + 1/2 * (0 + gamma * valores["C"])
    elif estado == "D":
        return 1/4 * (5 + gamma * valores["B"]) + 1/4 * (0 + gamma * valores["C"]) + 1/2 * (0 + gamma * valores["D"])
    else:
        return 0  # Estado desconocido


delta = float('inf') # Inicialización de delta con un valor grande
iteration = 0 # Inicialización del contador de iteraciones

while delta > threshold:
    delta = 0 # Diferencia máxima entre iteraciones, para evaluar convergencia
    iteration = iteration + 1
    valores_viejos = valores_estados.copy() # Guarda los valores de la iteración anterior
    for estado in estados:
        nuevo_valor = calcular_valor_estado(estado, valores_viejos) # Calcula el nuevo valor
        valores_estados[estado] = nuevo_valor # Actualiza el valor
        delta = max(delta, abs(nuevo_valor - valores_viejos[estado])) # Calcula la diferencia máxima

    # Imprime los valores en esta iteración
    print(f"Valores en la iteración {iteration}: {valores_estados}")
    print(f"Delta: {delta}")

# Impresión de Resultados Finales
print("\nValores de los estados después de la convergencia:")
for estado, valor in valores_estados.items():
    print(f"{estado}: {valor:.4f}")